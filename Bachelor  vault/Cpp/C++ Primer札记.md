### 4.11.2 显式转换

C++中定义了强制转换的语法，不同于旧式的C风格的强制转换（函数式`int(a)`和C风格式`(int)a`），其形式为
```c++
cast-name<type>(expression)
```

`cast-name`表示强制转换的方式；`type`表示转换的类型；`expression`即为表达式。

`cast-name`有三种类型，分别为`static_cast`、`const_cast`和`reinterpret_cast`。

- `static_cast`是用与有明确定义的强制转换，比如`double`转`float`等等；
- `const_cast`用于去除函数的`const`属性，**只使用于底层const**（也只有底层const被独立当为另一个类型）；
- `reinterpret_cast`是最底层的强制转换，他只负责让编译器改变类型的记忆，而不在位层面中做任何改变。

### 5.4.3 范围for语句

C++11所引入的范围for语句（range for statement），其语法格式如下
```c++
for (declaration : expression)
    statement;
```

declaration进行对变量的定义，expression中的所有元素的类型都应该能强制转化为该变量类型，最合适的方法就是使用auto声明。

expression中包含的是返回容器的表达式，该容器存在迭代器。

例子，将向量`vec`中的每个元素翻倍
```c++
vector<int> vec = {1, 2, 3, 4, 5};
for (auto &r : vec) {
    r *= 2;
}
```

为了保证能够对向量元素进行修改，变量必须被声明为引用。

### 对象的三个属性（作用域、链接类型和存储类型）

详见C和指针札记第三章。

### 引用（一般为左值引用）

为被引用的对象起了一个新的名字，引用即别名，**其本身不是一个对象**，所以不存在引用的引用。

除了**两个例外**，其他情况下所有定义引用时，左右两边的类型必须严格相同。（其中之一为常量引用）

引用只能用来绑定左值，比如字面量常量和表达式等右值都不行进行引用。

### const限定符

对用const修饰的变量加以限定，初始化以后的任何改变该变量内容的行为都会引发错误（同样对其的应用改变内容也会发生错误），所以定义const 变量必须要初始化。

默认状态下，在某一文件定义并初始化的const变量只能在当前文件夹中使用（即就算在代码外定义的const变量仍然是internal的链接属性），而编译器对此变量的用法就像`#define`一样直接进行常量替换（那如果此时变量的初始化值是一个表达式编译器该怎么做呢，算出当前的值然后再进行替换？）。如果要在多个文件中共享这个const变量，则有两种方法：

- 在每个文件都这样定义变量，此时每个文件的const变量都是独立的变量。

- 如果真的要在多个文件共享这个变量（比如这个const变量的初始化值是一个表达式），则**需要在const变量的声明的定义中都要添加`extern`关键字**（这一点是和普通变量不一样的地方）。
  可以理解为若为正常的变量定义，编译器是支持从其他文件链接到某一文件这个变量的定义的，只要在那个文件中声明。但是默认情况下的const变量只能被本文件中使用，所以需要在定义和声明处都添加关键字`extern`才行。

  ```c++
  // file_1.c
  extern const int bufSize = fcn();	// 声明并定义
  // file_2.c
  extern const int bufSize;	// 声明
  ```

常量引用：就是使用const引用一个常量（也用const修饰），简称而已，实际上是不存在常量引用的（用const修饰的引用以没用const修饰的变量初始化最终会报错），因为你无法保证引用的本身会不会改变。因为用const引用的对象必须是一个常量对象（const修饰），所以就叫常量引用，最终效果和用const定义一个变量一样。

引用左右两边类型必须相等的例外之一：常量引用（用const引用的简称），常量引用的右边不一定必须是const左值，也可以是右值，可以理解为反正常量引用的值后面都不会改变，所以最终其实和const定义一个变量的效果一样，究其原因，参考如下：
```c++
double dval = 3.14;
const int &ri = dval;
```

其等效为：

```c
double dval1 = 3.14;
const int temp = dval;
const int &ri = temp;
```

正是因为最终你不会改变引用常量，所以是允许新建一个临时量的。

```c++
/*
A -> B 表示用A引用B
常量引用 -> 常量	// 可以
常量引用 -> 变量	// 可以，左右值都可，编译器新建临时变量，再引用。
普通引用 -> 常量	// 不可以，已经规定了常量不可以改变，所以
普通引用 -> 变量	// 可以，左右两边类型严格相等
*/
```

**指针和const**

指向常量的指针（pointer to const），指针自以为是的认为自己不可以改变对象（可通过除该指针以外的途径更改）。

const指针：指针本身不可改变，而其指向内容的值是可能可以改变的。

```c++
int errNumb = 0;
int *const curErr = errNumb;	// 指针本身是常量，必须初始化
const double pi = 3.14;
const double *const pip = &pi;	// 指针本身即是变量，指向的值又是不可改变的常量（至少不可通过指针改变）。
```

顶层const和底层const：一般来说顶层const就是自己本身是常量的const，而底层const是指向的内容是const。多指指向常量的指针。对于底层const的拷贝操作，必须同样都是底层const才能进行。

```c++
const double *const pi = 3.14;	// 靠左const是底层const，靠右是顶层，指针的顺序刚好相反。
```

这一部分具体查书，现在没心思搞明白了。



### 函数

#### 函数基础

函数（function）包含：返回类型（return type）、函数名字、形参（parameter）列表和函数体（function body），如：

```c++
/* 实现阶乘 */
int fact(int val) {
    int ret = 1;
    // 循环不变式：目前为止已经计算了val_(val_ - 1)...(val_ - val + 1)，val_是最开始的val
    while (val > 1) {
        ret *= val--;	// (ret *= val--) == (ret *= val; --val;)
    }
}
```

其中我们通过调用运算符（call operator）来执行函数。

函数的调用：

- 用传入实参初始化形参，隐式。
- 主调函数（calling function）中断，被调函数（called function）执行。
- 遇到return时，控制权返回主调函数。

调用运算符内的形参列表所对应的表达式，没有规定求值顺序。

形参其实可以不命名，如果你不使用这个形参的话。

#### 局部对象

在C++中，名字有可视性，对象有生命周期（lifetime）

- 名字的可视性就是在程序的某一部分对该名字可见，可视性由变量声明的位置决定，如用static修饰全局变量可以让其只在一个文件中可见。
- 对象的生命周期就是程序执行过程中存在的一段时间，如局部变量。函数体外定义的所有变量具有所有的生命周期，其他变量的声明周期取决于定义的方式。

自动对象（automatic object）：该对象的声明周期为其定义语句开始到所处代码块结束的对象。形参就是一自动对象。自动对象定义创建之时若没有初始化，则执行默认初始化。

默认初始化：默认初始化就是声明时没有初始化，而默认值取决于所定义类型。对于内置类型，默认值取决于定义的位置，在函数体外的内置类型默认值为0，而在函数体内部将不被初始化，是未定义行为。局部静态变量初始化为0。

局部静态变量（local static object）：具有全部生命周期，但只在对应块的局部部分可见。

### 6.4 函数重载

**重载和const形参**
对于函数的形参来说，顶层const是没有效力的。也就是说，函数形参若为顶层const类型，那么实际传入该函数的参数是否常量都可以，也就是说，是否顶层const不能作为重载的区分。相反，函数形参的底层const是有效力的，即形参形式为底层const，实际传入的参数也必须为底层const（要不然就是非const转换成const），所以，函数重载的底层const和非底层const是有可以进行重载的。

只有当函数的操作极其相似时，再来考虑函数重载，其他情况还是尽量用函数名来标明其的作用。

**const_cast和重载**
这里给出const_cast强制转换与重载的搭配使用例子

```c++
const string &shorterString(const string &s1, const string &s2) {
    return s1.size() < s2.size() ? s1 : s2;
}

string &shorterString(string &s1, string &s2) {
    auto &result = shorterString(const_cast<const string &>s1, const_cast<const string &>s2);
    return const_cast<string &>result;
}
```



## 9 顺序容器

容器就是一些特定类型的集合。顺序容器（sequential container）就是在容器的基础上拥有其内元素的顺序依赖于加入该容器的相对位置。
### 9.1 顺序容器概述

| 容器名称     | 概述                                                       |
| ------------ | ---------------------------------------------------------- |
| vector       | 可变数组，支持随机访问，末位添加元素；不支持随机插入元素。 |
| deque        | 双端队列，头尾可出可进，支持随机访问。                     |
| list         | 双向链表。                                                 |
| forward_list | 单向链表。                                                 |
| array        | 固定大小数组                                               |
| string       | 保存字符的vector。                                         |

到了具体选择容器的时候再来考虑各种容器的优劣，这是数据结构的问题。

### 9.2 容器库概览

容器类型上的操作分为三类

- 所有容器有效的操作（使用所有容器都有的公共接口）；
- 只对顺序、关联、无序其中之一类型的容器的操作；
- 只针对一小部分的容器操作。

**哪些类型可以形成容器，哪些类型不能**
一般来说，所有类型，包括自定义的类型都能形成容器，这是由于容器本身是由泛型算法来编写的，只要该类型提供特定的操作，即可使用这些操作定义一个泛型算法，但是一些操作无法对自定义的类型进行，具体情况看具体的函数，那时可以判断出来。

#### 9.2.1 迭代器

不同容器的迭代器拥有者相同的一些接口，比如递增、递减、比较等等，所以可以由容器的迭代器作为参数来实现容器的泛型算法。

**迭代器范围**
头迭代器一般称为`begin`而尾迭代器称为`end`，迭代器的范围使用左闭合原则，即对于支持构成范围的迭代器来说，范围为`[begin, end)`。

#### 9.2.2 容器类型成员

每个容器中都定义了许多类型，包括前面介绍的`size_type`（用于表示容器的大小）、`iterator`（迭代器）和`const_iterator`，还有一些容器提供了反向迭代器，这里不讲。

剩下的就是类型别名，有`value_type`用于表示当前容器元素的类型，如果不知道该容器的元素类型（泛型编程），就可以直接使用这个类型别名；还有引用的类型别名`reference`和`const_reference`。

#### 9.2.3 begin和end成员

除了begin和end成员这种广为人知的成员，C++还提供cbegin和cend成员，用于返回一个常量迭代器。

对于begin和end成员来说，容器内部提供两种重载，一种是普通重载（不用const修饰），另一种就是常量重载（用const修饰），对于auto关键字，若使用begin或end成员，最终得到的类型取决于当前迭代器是本身是常量还是非常量，例如
```c++
auto it1 = a.begin();	// 得到的是iterator类型
auto it2 = a.cbegin();	// 得到的是const_iterator类型

const vector<int> b = {5, 6, 7};
auto it3 = b.begin();	// 得到的是const_iterator类型
```

#### 9.2.4 容器的定义和初始化

**将一个容器初始化为另一个容器的拷贝**
可以使用两种方式来进行新定义容器的初始化

- 直接拷贝整个容器
  ```c++
  vector<int> vec_1 = {1, 2, 3};
  vector<int> vec_2(vec_1);
  // eauql to 
  vector<int> vec_2 = vec_1;
  ```

  此时要求`vec_1`与要新建的容器类型完全一致，即既要相同的容器类型，也要相同的容器元素类型，是宏观的不涉及成员的拷贝操作。

- 使用迭代器拷贝
  ```c++
  vector<int> vec_3(vec_1.begin(), vec_1.end());
  // equal to 
  vector<int> vec_3();
  for (auto it = vec_1.begin(); it != vec_1.end(); ++it) {
      vec_3.push_back(*it);
  }
  ```

  此时不要求类型完全一致，只需要该被拷贝迭代器的成员类型能够转换至新建容器的成员类型，是微观的涉及成员的操作。

**列表初始化**
即使用类似如下的初始化方式

```c++
vector<int> vec_4 = {1, 2, 3, 4, 5};
```

列表初始化好像涉及到一个类型`std::initializer_list`，这个以后再来查。

**与顺序容器大小相关的构造函数**
即容器提供一个构造函数，其接收一个容器大小的，和一个可选的元素初始值，如下

```c++
vector<int> vec_5(5);	// 创建一个包含五个元素（默认初始化值为0）的容器
vector<int> vec_6(5, 2);	// 五个元素的值都为2
```

若顺序容器的成员类型为自定义类型，若该自定义没有默认构造函数，则使用该方式初始化时一定要显示初始化值。

**标准库array具有固定大小**
可以将array容器看成C++的数组，要创建一个array类型的容器必须要有一个固定大小（常量），就像C数组一样，也就是说，array的容量大小属于array类型，同时array容器支持使用初始化列表来进行初始化。

```c++
array<int, 10> = arr_1;		// 默认初始化（int为0，其他类型为其他类型的默认构造函数）
array<int, 10> = arr_2 = {1, 2, 3, 4};
```

array相比于C数组更加优越的地方在于其支持容器的拷贝操作，但是要求被拷贝的数组类型一摸一样，包括成员类型和容量大小。

再说一遍，容器元素的类型和容器大小同属于array类型的一部分。

#### 9.2.5 赋值和swap

array和vector都支持赋值运算
```c++
c1 = c2;
c1 = {a, b, c};		// c++ primer说array不能用列表赋值，但是实测可行（MSVC中）
```

上述赋值运算的原理都是新创建一个以被赋值容器（如c2和初始化列表）初始化的新容器，再将原来的容器析构，由此原来保存的容器迭代器等都会失效。

**使用assign（仅顺序容器）**
使用assign成员函数可以允许使用迭代器来进行赋值，如

```c++
vector<int> vec = {1, 2, 3, 4};
vector<double> vec_double {5.5, 3.3, 2.2};
vec.assign(vec_double.begin(), vec_double.end());
// vec的值变为{5, 3, 2}
```

assign的第二个重载版本支持使用个数和值来进行赋值
```c++
vector<int> vec;
vec.assign(5, 2);
// vec变为{2， 2， 2， 2， 2}
```

同样的，assign操作后的容器的原迭代器会失效。

**使用swap**
除了array容器，使用swap函数操作的两个容器仅仅只交换了名字，所以之前的迭代器等都没有失效，只是所属的容器交换了。

对于array容器的swap操作这里不谈，应该不常用。

使用非成员函数的swap版本是一个好习惯。

#### 9.2.6 容器的大小操作

若容器内部的元素支持大小操作，那么容器本身支持大小操作，其大小操作与字符串的大小操作类似，但是用于比较的两个容器必须具有相同的类型。

## 7 类

#### 7.1.2 类基础

**引入this**
我们在调用某个类的成员函数的时候，实际上隐性的传递了该类对象的参数，这个对象的参数被隐性的命名为`this`，其为一个常量指针，永远指向这个类对象，如调用

```c++
Student_info_2 a_student(std::cin);
a_student.name();
```

第二行等价于
```c++
Student_info_2::name(&a_student);
```

即将`a_student`这个类变量的地址传递给了`this`。

实际上，在类成员函数中调用本类的其他变量或函数时，都是隐性的调用`this->var`，如
```c++
std::string Student_info_2::name() const {
    return this->name;		// 等价于 return name;
}
```

**引入const成员函数**
回顾const与指针的关系，我们不能将指向非常量的指针（`int p`或者`const int p`）指向一个常量对象。前面提到，调用类的成员函数隐性地传递了一个指向非常量的常量指针`this`，那么如果我们想传递的是指向常量的常量指针呢？也即`const Student_info_2 *const`类型给`this`，也就是说我们不想该成员函数有资格改变类内的变量。我们本可以在`*`操作符后面添加`const`，但由于成员函数是隐性传递给`this`，所以C++语法允许我们在形参列表之后，函数块之前添加`const`（声明的时候也需要包含`const`）。

这里提一嘴，类先定义类的变量成员，再定义类的函数成员，所以类的成员函数可以调用定义在之后的成员变量。

**在类的外部定义成员函数**
和其他函数的声明一样，类的成员函数的声明和定义也要匹配，匹配体现在返回值，形参列表中。由于成员函数隐性传递对象常量指针的规则，所以该指针是否指向常量变量的信息也要匹配，也就是说，声明中形参列表带`const`，定义中也要，如

```c++
std::ostream &show(std::ostream &out) const;	// 声明

std::ostream& Student_info_2::show(std::ostream& out) const {
	// ...
}
```

**定义一个返回this对象的函数**
当我们在写一个类似于内置运算符的函数时，我们要尽量地模仿内置运算符。赋值运算符（`=`或`+=`）将其的左侧运算对象当作左值返回。*不知道为什么赋值运算符是这样*

```c++
X& operator+=(const X& rhs) // compound assignment (does not need to be a member,
{                           // but often is, to modify the private members)
    /* addition of rhs to *this takes place here */
    return *this; // return the result by reference
}
```

赋值运算符为特殊二元运算符，特殊在其返回的值会重新赋给运算符左边的值。

#### 7.1.4  构造函数

构造函数（constructor）的名字和类名一样，没有返回值，不能被声明成const，因为构造函数就是用来给初始值的，只有在初始值给了之后才存在常量这一说。

**合成的默认构造函数（default constructor）**
当类中没有任何构造函数时（一个都没有，不管是不是默认构造函数），编译器会自动根据类内变量的类型的生成一个默认构造函数，其就叫做合成的默认构造函数。默认构造函数按照如下规则来基于变量初始值

- 类内有初始值，则直接按照初始值生成默认构造函数；
- 否则，默认初始化。

注意，只有一些简单的适合合成默认构造函数，普通一点的类建议都自己写，原因如下

- 第一点刚才说过，只有当一个构造函数都没有，编译器才自动生成合成的默认构造函数；
- 默认构造函数对于内置变量会默认初始化，这常常会导致错误；
- 类中包含没有默认构造函数的类，那么合成默认函数无法生成。

**default默认构造函数**
如果你已经有了一些非构造函数，那么根据刚才所说的，编译器无法生成合成的默认构造函数，所以此时你需要自己定义。如果你此时仍然想让默认构造函数和编译器生成的合成默认构造函数相同，你可以在声明中（定义也可以，但是一般不这么干）使用`default`，如下

```c++
Person() = default;
// 或者这样
Person(); // 类内
Person::Person() = default; // 类外
```

**构造函数初始值列表（constructor initialize list）**

```c++
Student_info_2(): name(std::string()), midterm(0), final(0), 
                    grade(0), homework(std::vector<double>()) {}
```

如上，在函数体之前和形参列表之后，有着使用`:`引导的，`,`分隔的，由类内变量与括号组成的列表，我们称之为构造函数初始值列表。顾名思义，其用来为构造函数初始化类的成员变量（所以只能在构造函数中使用）。我们可以选择将类内的所有变量都显式的初始化，同上面一样，也可以像下面一样只选择部分进行初始化，此时其他未显式的类内成员变量隐性的由同合成的默认构造函数一样的方式初始化。最后，如果全部都没有显式初始化，那么全部都使用默认初始化。

初始值列表中括号前的内容可以看成该变量表示的类型，而类型加上括号就是该类型的构造函数，比如`name(std::string())`等效于`name()`，都是给变量`name`以`std::string`的默认构造来初始化。

#### 7.2.1 友元

有时候会定义一些全局的不属于某一类的函数，但是这个函数需要访问类中的私有数据。C++允许在类中的任意地方（一般以集中在开头）添加一个友元声明，表示这个函数是这个类的好朋友，允许这个函数访问类的私有数据。

```c++
class Person {
friend bool compare_person(const Person& lhs, const Person& rhs);
public:
    // ...
};
```

友元的声明一般来说是与正常的声明是独立的，也就是说，友元声明只是表示类和函数的友元关系，而无法让编译器知道这个函数是否声明。只有另外再声明这个函数，才能正常的使用这个函数。

#### 7.3.1 类成员再探

**定义一个类型成员**
除了成员变量和成员函数之外，还存在一种类型的类成员，也就是成员类型，即在类中的类型别名，可以在类中使用`typename`和`using`等关键字定义。

```c++
class Screen {
public:
	typedef std::string::size_type pos;

};
```

注意，类型成员同样也有访问权限的设定，在public关键字中，就可被用户访问，反之则反。还有，类型成员的定义在类中是有先后顺序的，必须先定义再使用。

**令成员作为内联函数**
对于一些简单的成员函数，可以直接再类中定义，同时你也可以添加`inline`关键字，从而在类外（但**同一头文件中**）实现函数定义，如下

```c++
template <class T>
class Vec {
	size_type capacity() { return (size_type)(limit - data); }

private:
	inline void create();
};

template<class T>
inline void Vec<T>::create() {
	data = limit = avail = nullptr;
}
```

**Why size_t and ptrdiff_t matters?**
`size_t`是一个数据类型，通常为某大小的无符号整数类型，在不同的平台上有可能有所不同。同样你也可以认为`size_t`类型是`sizeof`关键字返回的类型。其实际含义为该类型表示的数据范围能容纳下该平台下任何有可能出现的对象（比如说数组）的最大长度，其为C语言的概念，包含库参阅cppreference。
在C++中同样可以使用该类型`std::size_t`，定义在`<cstddef>`等中。`size_t`的重要性在于其对代码的移植性、易读性等方面有巨大的提升。

同样`ptrdiff_t`是个某大小的有符号数，其表示两个指针相减（如果可能的话）的结果类型。

**可变数据成员（mutable）**
若我们将类的某个成员函数声明为了const，那么我们就无法通过该函数改变类中的数据成员。可以使用`mutable`关键字声明某个数据成员，如此，用const声明的成员函数也能够改变mutable关键字修饰的变量。

**类内初始化**
不光只有构造函数的方式可以进行对数据成员进行初始化，也可以直接使用类内初始化。类内初始化的方式就是直接在类数据成员声明的时候使用`=`或花括号进行即可。

#### 7.3.2 返回*this的成员函数

我们通常将公共的成员函数的返回值定义为`*this`，这是因为如此便能在一行中同时进行多次成员函数操作，如
```c++
myScreen.move(4, 0).set('#');
```

如果成员函数的返回值为`*this`，在`const`的情况下会略微繁琐。若是该成员函数不需要改变类内的数据，我们通常会将其声明为`const`，即该成员函数无法改变类内的数据成员。我们知道，成员函数的`const`的机理在于将类作为底层const传参给成员函数并且最后返回，由于底层const的特殊性质（一是作为一个独立的变量类型；二是非常量能隐式转换为常量类型），底层const无法（再次调用非常量的成员函数）进行同一行多次成员函数的操作。这个时候就要进行`const`的重载。我们通常用一个中间私用函数来进行，如下
```c++
class Screen {
public:
	Screen &display(std::ostream &out);
	const Screen &display(std::ostream &out) const;
private:
	void do_display(std::ostream &out) const { out << contents; }

};

Screen &Screen::display(std::ostream &out) {
	do_display(out);	// 非常量*this转化为常量*this
	return *this;
}

const Screen &Screen::display(std::ostream &out) const {
	do_display(out);
	return *this;
}
```

**两种为底层const重载的方式**
结合6.4节与本节，对于类成员来说，底层const的重载应使用返回值为`void`的中间函数，该函数的核心利用的是非const能够转化为const而没有返回值（返回值由外部负责）。
对于非类成员函数，巧妙使用`const_cast`强制转换来实现。

### 7.4 类的作用域

在类内，你可以直接访问类的成员，而在类外，你必须依托于某对象或者类名来访问类内成员，这是因为类内的成员的作用域在类内，所以在类外访问必须先访问类，再访问成员。这一点可以很方便的通过类外定义函数的方式来进行，如下
```c++
Screen::pos Screen::size() const {
    return height * width;
}
```

我们将上述代码分成两个部分，其中一个部分是函数的返回值，另外一部分就是除去返回值剩下的部分。为什么这么分呢？先说返回值之外的部分，我们在函数名中告诉了编译器我们所要访问的类对象，所以之后的部分要再访问类内对象，编译器已经默认转换为了该类的作用域，所以不许再次指明类对象。对于返回值来说，编译器认为其属于类外部分，不受函数名指明类的影响，所以要让返回值返回某类的成员，必须再次指明类名。

### 7.5 构造函数再探

#### 7.5.2 委托构造函数

有的时候多个不同的构造函数需要为一个或几个的成员数据提供相同方式的初始值，这样的代码就显得有点繁琐，可以使用委托构造函数来简化这一操作，如下
```c++
class Screen {
public:
	Screen(): Screen(0, 0, ' ') {}
	Screen(pos ht, pos wd, char c = ' ') : height(ht), width(wd), contents(ht* wd, c) {}

};
```

我们首先定义了一个三个参数的构造函数。对于默认构造函数来说，我们直接将构造的任务委托给三参数构造函数，并传递对应参数，即可达到简化代码的目的。

注意，上述的默认构造函数先调用三参数的构造函数，在执行完三参数构造函数的函数体之后再继续初始化默认构造函数的其他数据成员（这里没有），再指向默认构造函数的函数体。
