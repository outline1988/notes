*2022.8.2*

### 一、快速上手

#### 循环输入数字

```c
/* [0 : num - 1]下表已经完成输入 */
while (num < max && scanf("%d", &columns[num]) == 1 
       							&& columns[num] >= 1) {
    ++num;
}
/* （有次数限制max，有终止条件） */
```

- 其中while中的`&&`运算符优先级较低，为左结合律，左边组合在一起。
- 三个并列的`&&`语句第一个为次数限制（num从0开始）
- 第二个为读取，第三个为读取的值判断，只有读取完后才能判断，所以先后顺序有要求（由短路原则可以知道，&&的求值顺序一定是从左到友）。

处理后面的其他杂项输入
```c
/* 只有到了文件末位和换行才会停止循环 */
/* 循环不变式：目前为止还没有遇到输入结束和'\n'换行 */
while ((ch = getchar()) != EOF && ch != '\n') {
    ;
}
```

赋值表达式的返回结果为最左边的值。

EOF的定义在`stdlib.h`中`#define EOF (-1)`

#### 删除一段代码

一般来说习惯直接注释掉，但是直接注释有时会出问题，如果注释的内部也有注释的画就注释不了（只限于`/* ... */`），真正意义是从逻辑上删除一串代码可以用

```c
#if 0
	statements
#endif
```

*这真的是快速上手吗，给小白看这个代码不是直接劝退吗。。。*

### 二、基本概念

#### 翻译

翻译（translation）是将源代码翻译成可执行的机器指令的过程（还没有执行），其组成可包含编译和链接。

`gcc *.c -o filename.exe`其中`filename.exe`就是最后的可执行文件。

- 编译：将源文件转换成目标代码（object code）文件，其也可分为几个过程`gcc -c test.c -o test.o`
  - 预处理（preprocessor）：对代码进行文本操作`gcc -E test.c -o test.i`
  - 解析（parse）：由此产生可能出现的警告和错误
    - `gcc -S test.i -o test.s`：预处理后生成汇编代码
    - `gcc -c test.s -o test.o`：汇编代码转换成机器语言，可以直接使用这个代码操作.c文件
  - 优化（optimizer）：可选
- 链接：将目标代码中声明过但没有定义的操作在其他目标文件（包括库函数）找到并对应起来，也就是多合一的过程。
  `gcc -c *.o -o test.exe`

可以理解为`gcc -c`是全能的，一步出结果的，后面可以接绝大多数格式的文件，编译器会自动帮我们转换。

**执行过程**概述（对于一般的操作系统来说）：

- 程序载入到内存中，那些全局变量开始拥有初始值。
- 开始：先开启小型的启动程序（由它来执行一些日常事务），从而调用到main函数。
- 过程：运行到函数或是局部区域的时候，产生堆栈存储局部变量和返回地址，若有静态（static）变量，也可将其存储到静态内存中。
- 函数返回（可能由各种各样的异常返回，一般是return 0），启动程序再次获取控制权，再次处理各种日常事务，如关闭程序打开但未关闭的文件等等。

### 三、数据 & 四、语句

#### 数据类型

**标准规定的最小范围**

| char     | short        | int                      | long                   |
| -------- | ------------ | ------------------------ | ---------------------- |
| 8bit     | 16bit        | 16bit（但一般都是32bit） | 32bit                  |
| -128~127 | -32768~32767 | -32768~32768             | -2147483648~2147483647 |

int的位数一般设置为极其处理最高效的位数。

不同编译器的char类型是不一样的，有可能是有符号，也有可能是无符号（取决于哪个更为高效），ascii位于有符号与无符号的交集，是可以移植的。

**整型字面值**
默认情况下（缺省、default）：字面值就是能够包含该常量大小的最小类型。

**字符串字面量**
在程序中使用字符串字面量实际上是使用指向该字符串的指针，但是你不能通过该指针对字符串常量进行操作，这是未定义行为。

**无符号数和有符号数**
无符号数就是将有符号数中的负值部分用来拓展正值的范围，当其在有符号正值范围的时候二进制嘛与无符号相同，所以使用无符号和有符号的转换只要注意是否有负和超出有符号正值的范围，这点在判断大小的时候尤其要注意。



#### 声明

声明语句的基本结构为：
*说明符（一个或多个）  声明表达式列表*

其中理解这个表达式很重要，以下为对此的举例。

**声明简单数组**
`int values[20];`用来理解的方式为：通过对values增加下标`[]`来表示增加了下标之后为`int`（说明符）类型，其中的20表示有20个这种数据。**对于数组超出范围，一般的规则为，在内部使用无需判断是否超出，但是若是用户输入，则必须判断是否超出范围。**

**声明指针**
`int *ptr;`将其理解为ptr增加`*`运算符后表示`int`类型的数据，所以是指向`int`的指针。

**typedef**
要将typedef也理解为声明语句，如

```c
typedef char *ptr_to_char;
```

其前面的`typedef char`为说明符，用来表示即将创建一个新的类型名字用来表示`char`，最后的`*ptr_to_char`为声明表达式，表示新的名字就是`ptr_to_char`。

但是在对其初始化的时候并不是对其表达式进行赋值的，而是对其本身进行赋值，如

```c
char *message = "hello";
```

上述语句等价于

```c
char *message;
message = "hello"
```

#### 作用域

标识符被声明的位置决定了其作用域，也就是C++ Primer中的名字具有可视性（对象具有生命周期）。

**代码块作用域（block scope）**
位于花括号之间的区域称之为一个代码块，在花括号之内声明的变量都具有**代码块作用域**，同样也包括函数形参。

注：K&R C的函数定义为两个相互嵌套的代码块，故内层可以声明与形参相同的变量名字，但是ANSI C扼制了这样的可能，它将整个函数视为一个代码块。

**文件作用域（file scope）**
在代码块之外声明的标识符具有**文件作用域**，作用范围就是声明语句之后，此源文件之前。

**原型作用域（prototype scope）**和**函数作用域（function scope）**

原型作用域就是在函数原型中所声明的变量，但实际上函数原型中名字不是很重要，只要在同一原型中没有重复名字就好了。

如果你用到了函数作用域，那么建议你重写代码。 

关于对象的三个属性：作用域，存储周期，链接属性，请看这个网站[【对象的三个属性】](https://stackoverflow.com/questions/24864840/difference-between-internal-and-no-linkage)。

#### 链接属性

标识符的链接（linkage）属性决定了不同位置相同标识符的声明（注意一定是声明，带了初始化就成了定义了）中，每个标识符究竟属于哪些的实体。

链接属性共有三种：external（外部）、internal（内部）和none（无）。

无链接属性的标识符每次声明都是一次定义，每次的声明都被当作不同的实体，如在两个独立的代码块或嵌套的代码块声明变量（也就是自动变量）。

internal属性的标识符只在同一源文件的（多个）声明时指向同一实体，不同源文件的声明指向不同实体。

external属性的标识符在整个工程文件中都指向同一实体。

默认情况下具有文件作用域的标识符（代码块外面定义的变量）定义为外部（external）链接属性，可以在其他文件中用`external int a;`的声明来使用这个变量。

请务必注意要将声明和定义区分开来，这里仅仅只讨论声明。

再说吧，不看了

#### 存储类型

存储类型（storage class）就是指变量定义时使用计算机硬件中的那块内存，包括普通内存、运行时堆栈和硬件寄存器，并且默认由声明位置决定，也就是C++ Primer中的对象具有生命周期。

代码块之外声明属于静态内存，此对象在程序运行之前就存在，并且一直保持直到运行结束，因此也不能改变其存储类型。

运行时堆栈对应自动变量，就是代码块内建立，代码块结束销毁。

寄存器变量暂时不研究。

关于静态变量和自动变量的初始化问题：由于静态变量存储于普通内存中，在程序运行之前已经确定，所以初始化时可以直接把初始化值放在对应的内存区域中，从而实现初始化，由此静态变量的初始化比后面赋值的效率要高。自动变量存储的位置位于运行时的堆栈中，故无法提前确定自动变量初始化时的内存位置，所以若不指明初始化值，初始化值常常为垃圾值（究竟是不是还得取决于编译器），同时自动变量的初始化和赋值的开销时相同。

#### static关键字

static用以改变默认对象的三个属性，不同的环境中使用static会有不同的效果，这里先简明述说以下区别。

- 当static用于**函数定义**或在**代码块外**声明时，其作用为将标识符的链接属性由external改为internal，即将此标识符定义为仅由本文件中使用。
- 当static用于代码块内部的变量声明时，其作用就是改变标识符的存储类别，即将自动变量改为静态变量，由此此变量的存储位置就位于普通的内存中。

#### 一些编程小技巧

- 如果需要根据递推关系式，从初值递推至某个值（前提是递推关系收敛到某个值），但是不知道需要地推的次数是多少，这时可以用上一次和这一次的结果做比较作为循环地推的条件，相等则达到了内置double类型的精度，就可以停止循环了。
- 字符串复制，两个字符数组，在遍历时使用两个index分别用作两个数组，其中一个作为for循环的标志，另外一个在达到某种条件的时候才继续增加，从而达到一次遍历的效果。
- for循环中若有if判断后break退出的，可以将其集中到for中，简化代码，阅读代码的时候若for中很多判断条件也可先读主要的然后将后面的放在循环末位用if-break来替代，注意for中的逻辑和if-break的判断逻辑是相反的。

### 五、操作符和表达式

#### 布尔值的使用技巧

由于C中没有正真意义上的bool类型，而是用整数来代替，0为假，非0为真。

但是实际的使用中很容易出现布尔值和整数的混用从而导致出乎意料的结果，比如如果有`#define TRUE 1`，这样很容易出现类似于`a == TRUE`这种错误的写法而将此表达式限制为只有a为1时才是真。

为了避免上述情况，最好的方法就是不要混用布尔值和整数值（虽然本质上两者相同），你要有意识的区分这两个变量，当需要用包含任意数的变量组成逻辑表达式时，必须显式写出`if (value != 0)...`，若出现你设置变量表示布尔类型的时候，你需要保证它只有0和1两个值，此时最好直接进行判断`if (positive_cash_flow)...`。

#### 左值和右值

和你理解的一样，左值表示了其在内存中拥有一个位置，即表示了一个可以存储结果的地点，右值指定了一个值。

```c
a = b + 25;
```

对于上述的例子，在计算机计算`b + 25`时，其结果虽然保存在内存中的某个地方，但是由于你无法预测存储的地方，同时你也无法确定下次是否存储于同一个地方，所以其值为右值，基于同样的理由，字面值常量也是右值。

但不要因此而理所应当的认为表达式都是右值，如同`a[5]`或是`*p`等表达式都是左值。

#### 表达式求值

**隐式类型转换**

操作数进行算数计算的时候，通常是默认的类型进行计算效率更高，所以当进行计算时，就算类型都不是默认类型，也要转为默认类型在计算，例如

```c
char a, b, c;
...
a = b + c;
```

char类型的b和c在进行加法运算的时候都会**整型提升（integral promotion）**，在进行计算。

**算数转换**

同一操作符中的操作数的类型若无法与规定的操作符所需的类型对应，就会进行类型转换，例如

```c
int a = 5000;
int b = 25;
long c = a * b;
```

若位于16为的机器，在进行c的初始化的时候会出现问题，a*b会以int类型返回结果，而此结果会溢出，所以导致最后计算错误，但如果稍作修改，即可解决这个问题

```c
long c = (long)a * b
```

原因在于(long)a*b的结果返回long类型，不会发生溢出，所以最终正确。

**优先级、结合律和求值顺序**

需要纠正的是，优先级和结合律都是针对相邻两个操作符出现时，表达式的顺序是如何的，如

```c
a * b + c * d + e * f;
```

上述表达式不一定是先把所有\*计算出来，只需要要求\*操作符的运算在**相邻**的操作符+之前运算即可，所以也可能是(a **\*** b) -> (c **\*** d) -> (a **\*** b) **+** (c **\*** d) -> (e **\*** f) -> (a **\*** b) + (c **\*** d) **+** (e **\*** f)，这是因为优先级只要求优先级高的运算符在优先级低的运算符先执行，在配合着结合律的规定，程序是能正确的将表达式求值的。

对于单运算符，究竟是左操作数先求值还是右操作数先求值是由编译器决定的，所以是未定义行为，如`c + --c`，没人知道左边的c是在`--c`之前还是之后，而且这点对这个表达式来说特别重要。

将每一个操作符都当作一个函数，而操作符的操作对象当作函数时参数，而操作符的优先级和结合律就决定了函数参数应该为表达式中的哪一个部分。

优先级具体规定的是当两个级别不同的操作符相邻时，哪一个操作符先进行的问题。

结合律具体规定的是当两个或多个优先级级别相同的操作符相邻时，具体的组合方式。

```c++
double a = 10 * 20 / 5;
// 等价于
double b = (10 * 20) / 5;	/* '/'的左结合律，故左边括号 */
```

**逗号操作符**

逗号操作符可以将多个表达式分隔开来并共同组成同一语句，并且整个表达式返回的值是最右边表达式的值。

利用此的特性，可以使用逗号操作符来进行while循环的更新语句，从而将更新语句集中，增加易读性，如

```c
while (a = get_value(), count_value(a), a > 0) {
    ...
}
```

上述代码中的while语句的判断表达式由于使用了逗号操作符，所以只有a>0对while循环的判断具有作用，并且将更新语句集中在了一起，更加的简洁。  

### 六、指针

#### 一些关于指针的知识

事实上仅仅拥有某个内存地址的内容是不行的，这个地址上的内容真正代表着什么，还得取决于你的使用方式，即表示的类型，而这点是依靠编译器来建立联系的。

应该视指针为某个内存区域存储的一些**数值**，这些数值代表着一个地址，在离开了间接访问（解引用）的操作，这个数值将一无是处，毫无意义。

NULL指针实际上并非一定代表0，但是编译器会将NULL指针与0产生联系。

声明定义指针时必须初始化，若有明确的初始值则使用此初始化，若没有则初始化为NULL。

指针常量用到的情况很少，因为你需要提前知道某个特定的地址，而且固定的地址非常少见，通常是要访问硬件。由于C语言中没有内建的指针常量的记法，所以通常是先用整型字面量，然后再将其强制类型转化为适当的指针类型。

#### 指针的运算

**指针 + 整数**
标准定义其只能用于指向数组的指针，即表示这指针在数组元素的移动，值得注意的是，指针指向数组第一个元素之前或最后一个元素之后都是未定义的，但是让指针指向数组最后一个元素的下一个元素是**合法的**，但是**不能访问**。

**指针 - 指针**
相当于对应下标相减，类型是ptrdiff_t（有符号的整数类型），注意此时仍然需要两个指针指向同一数组的元素。

**关系运算**
当使用关系运算来进行数组遍历时，要保证用于比较的指针在数组范围之内，一般仅仅使用大小与或不等都是不会出现这个问题的，但是如果判断包含相等的条件就是出现最后比较的时候超出边界从而未定义，如

```c
// 循环不变式：(value[N_VALUES], vp]已经清0
for (vp = &value[N_VALUES]; vp > &values[0]; ) {
    *--vp = 0;
}
```

上面的代码是可行的，因为使用了大于操作符，所以不会产生指针超出边界的情况。
```c
// 循环不变式：[value[N_VALUES - 1], vp)已经清0
for (vp = &value[N_VALUES - 1]; vp >= &values[0]; vp--) {
    *vp = 0;
}
```

上面的代码当最后一次循环的时候，vp指向数组第一个元素的前一个元素，超出边界，所以其进行关系判断是未定义行为。
反正综上所述，利用数组的指针进行遍历时，一定要检查是否会出现超出边界的指针进行关系判断（超出边界仅仅只有一种情况是合法的，就是最后一个元素后面的元素，但是经常使用）

### 七、函数

#### 追踪递归函数

当函数被调用的时候，在被调用的函数创建的变量存储于运行时堆栈，并且同时掩盖前一次调用函数（未运行完）所创建的变量。

#### 尾递归

尾递归（tail recursion）调用执行的是当前函数的最后一项任务
```c
long factorial(int n) {
    if (n <= 0) {
        return 1;
    }
    else {
        return n * factorial(n - 1);	// 递归是最后一项调用，所以是尾递归
    }
}
```

尾递归很容易写成循环模式，而且通常效率也更高。

**编程小技巧**

使用while的固定次数循环一般为
```c
// loop n times
// range: statement_1 [n : 0) or statement (n : 0]
while (n > 0) {
    statement_1;
    --n;
    statement_2;
}
```

如上代码，如果你要使用n的范围是[0 : n - 1]，请在statement_2处写代码；如果是[1 : n]，请在statement_1处写代码。

**kmp算法之求next数组**

```c
void compute_prefix(const char *pattern, int next[]) {
    int prefix_index = -1;   // 指向前缀的最后一个元素，默认是-1表示第一个元素没有公共缀
    int suffix_index = 0;   // 指向后缀最后一个元素的下一个元素，从0开始

    next[suffix_index++] = prefix_index;  // 第一个元素一定是-1
    while (pattern[suffix_index] != '\0') {
        /* -1表示没有公共前后缀 */
        while (prefix_index != -1 && pattern[prefix_index + 1] != pattern[suffix_index]) {
            prefix_index = next[prefix_index];
        }
        if (pattern[prefix_index + 1] == pattern[suffix_index]) {
            ++prefix_index;
        }
        next[suffix_index++] = prefix_index;        // 递进suffix_index同时更新next数组
    }
}
```

考虑你已经知道了某一个字符前面字符串的next值，你即将求下一个元素的next值，你将下一个元素与前缀的后一个元素进行判断，若相等，则下一个值就是前一next值加一，若不相等，则表示着前缀需要减小，那么具体减小到多少呢，应该减小到当前前缀最后一个字符所对应的最长公共前缀，可以保证的是这一前缀与前述的后缀的有相同区域的，如果一直不相等，则最后会到-1（具体因代码而异）表示没有公共前后缀，如此便退出循环。



#### 可变参数列表

C对于可变参数是通过stdarg宏来实现的，这些宏存于`stdarg.h`头文件，所需的只有一个类型`va_list`，三个宏`va_start`、`va_arg`和`va_end`，通过这些宏，便可访问可变参数的值，如

```c
#include <stdarg.h>

float average(int n_values, ...) {
    va_list var_arg;	// 用以表示省略号所代表的值的类型
    va_start(var_arg, n_values);		// 定位...的位置以便对var_arg初始化
    
    float sum = 0;
    for (int i = 0; i < n_values; ++i) {
        sum += va_arg(var_arg, int);		// 获取可变参数，int用来表示参数的类型
    }
    va_end(var_arg);	// 完成处理可变参数
}
```

以上便是可变参数的具体用法，需要注意的是

- 一定需要`...`前面有形参来定位其的位置
- 只能从第一个值开始访问，不能从中间开始。

### 八、数组

#### 一维数组

**数组和指针**
不应该把数组名与指针等价，诚然其在各种表达式中数组名有着与指针常量相同的特性（其值代表着指向数组第一个元素的指针常量），但是编译器也通过数组名来记住一些有关数组的特性，比如使用`sizeof`的时候返回的是数组的字节大小，取数组名的地址表示指向数组的指针而不是指针常量的指针。

同时，考虑下面两个声明
```c
int a[5];
int *b;
```

a为数组，所以在声明的时候就自动为其开辟合适的内存大小，并让a指向内存的第一个元素；而b仅仅只是个可能没有初始化的指针（作为自动变量就没有初始化）。

**指针和下标**
下标检查，即对于某个指针的下标访问操作是否属于同一个数组，也即有没有超出边界，在C中是一项困难的任务，原因在于需要判断指针与指针的下标表达式是否指向同一数组，由此便要求记住数组的长度和位置方面的信息，并且当程序运行的时候，数组的信息也需要动态的更新以适配数组动态的创建。

选择指针间接引用还是选择下标引用呢，如果单看这两个指令，其效率完全相同，要区别效率问题在于其不同的工作环境的效率，总的来说，指针比下标更有效率，前提是你能够正确的使用，还有一句话，**不要为了效率上的细微差别而牺牲可读性**。

**声明数组参数**
正确的函数形参声明数组有两种写法`int strlen(char *string)`和`int strlen(char string[])`，第一种写法揭示了在函数的传参过程中，数组与指针无异，并且其也更加准确。第二种通常是为了让C语言变得看似更容易上手而使编译器接受这一形式的，但是实质上这是不准确的，因为其虽然声明为数组的形式却没有数组区别于指针的特性，比如使用`sizeof`得到的仍然是指针的大小而不是数组的大小，所以在使用的过程中还是应该使用指针的声明。

**初始化**
数组的初始化和一般标量的初始化遵循的规则几乎相同，只不过在于较大的数组要完整的初始化需要较多的初始值，所以需要考虑若是将数组设为自动变量，即在代码块中声明，是否值得将其设为静态变量以消除重复进入代码块时数组初始化所带来的开销。

不完整的初始化只允许省略后面的几个，并将未提及的元素都初始化为0。

#### 固定数目循环效率的研究

初始化代码

```c
#define SIZE 50
int x[SIZE];
int y[SIZE];
int i;
int *pi, *p2;
```

1. 使用下标
   ```c
   void try1() {
       for (i = 0; i < SIZE; ++i) {
           x[i] = y[i];
       }
   }
   ```

   此版本在每次运行至循环体中`x[i]`和`y[i]`时都需要将`i`乘4后再加到指针中。

2. 改用指针
   ```c
   void try2() {
       for (p1 = x, p2 = y; p1 - x < SIZE; ) {
           *p1++ = *p2++;
       }
   } 
   ```

   相比于try1，其循环体的效率更高，但是每次循环的检查判断都要对表达式求值，从而检查语句的效率更低。

3. 计数器中使用指针
   ```c
   void try3() {
       for (i = 0, p1 = x, p2 = y; i < SIZE; ++i) {
           *p1++ = *p2++;
       }
   }
   ```

   相比于try2，通过使用计数器，增加了运行判断语句时的效率；相比于try1，其在循环体中使用了指针克服了下标需要时刻乘4的问题，但上述代码引入了计数器。

4. 寄存器指针变量
   ```c
   void try4() {
       register int *p1, *p2;
       register int i;
       
       for (i = 0, p1 = x, p2 = y; i < SIZE; ++i) {
           *p1++ = *p2++;
       }
   }
   ```

   上述代码在继承了try4的优点上，又进一步的使用寄存器变量从而减小了循环体中需要将变量从内存移至寄存器的开销，从而提高了效率。

5. 消除计数器
   ```c
   void try5() {
       register int *p1, *p2;
       
       for (p1 = x, p2 = y; p1 < &x[SIZE]; ) {
           *p1++ = *p2++;
       }
   }
   ```

   此代码完全可以与汇编程序员写的代码相媲美：）

6. 综上所述，当进行固定数目的循环时

   - 使用指针的移动来访问来循环。
   - 在循环体中使用寄存器变量，也就是将指针声明为寄存器变量。
   - 进行判断语句时，减小表达式的求值，如使用&array[SIZE]的常量表达式代价要小。
   - 如果你不想这样写，你也可以不这样写，因为较之可读性来说，效率的一点点提升没有一点用，代码的易读性和简洁性是最重要的。

#### 多维数组

```c
int d[3][6][9];
```

应该这样理解，d是一个包含三个元素的数组，而其每个元素又是包含6个元素的数组，而这个元素又是一个包含9个元素的数组，理解时应该从左到右逐级推进。

**存储顺序**
按照上述理解，对于`int matrix[3][6]`，首先应是个三个元素的数组，故在内存中为三个连续的内存块，然后这三个元素的每一个元素，又是一个包含六个元素的数组，所以这一个内存块内又包含了六个连续的整型大小的区域。C中的数组元素的存储顺序也确实是这样的，并且其遵守按照最右边的下标先变换的原则。

matrix这个数组名的值是指向包含六个整型的数组的指针，matrix[2]是指向整型的指针，故对matrix的解引用得到的是数组，对matrix[2]的解引用得到的是整型。

将数组名理解为代表整个数组的变量，只不过在表达式中用到的时候只表现出为其是指向第一个元素的指针常量（右值属性）。而指向数组的指针也就是一个记录着这个数组地址的另外一个变量，凑巧的是，数组名也表示这个数组第一个元素的地址，但是若要进行算术运算，则结果会因其类型不同而有不同。

**指向数组的指针**
数组名是实实在在占据有内存一定位置的变量，单独的变量名在表达式中而不对其进行间接引用，其表示的结果为指向第一个元素的指针，更形象的理解，就是数组占据内存中位于前面区块的地址。由于其占据一定位置，故数组也存在指针，其存储的值就是存储数组的地址，只不过刚好与数组第一个元素的地址相等罢了。

```c
int (*p)[10];
```

可以用表达式的观点来看待声明，只有p为指针才可以间接引用，只有*p是数组才可以使用下标，所以p是个指向数组的指针，声明中的[10]表示指向的数组有是个元素。

当多维数组用于函数的传参变量时，本质上函数传递的是个一维数组，因为多维数组本质就是一维数组，只不过一维数组的元素是另一数组，所以若是传递二维数组，传递给函数的形参声明应该为多维数组抽象出的一维数组的指针，其函数原型如下
```c
void func(int (*matrix)[10]);
void func(int matrix[][10])
```

matrix表示指向有十个整型元素的指针，其中[10]是必要的，他表面了传递的一维数组包含元素的信息，第一行的代码更形象的表示matrix是指向数组的指针，第二行只不过为了好理解而特意而为之，形如下面的声明是不行的
```c
void func(int **matrix);
```

这种声明表示的是声明一个指向指针的指针，被指向的指针指向int类型，若要与数组指针强行联系，也就是数组指针接引用后再下标后的取地址。

**初始化**
多维数组的初始化方式有两种，一是只用一层花括号，内有长长的初始值列表，其的原理是依据存储顺序是由最右边下标最先变换的原则确定的，如下

```c
int matrix[2][3] = {00, 01, 02, 10, 11, 12};
```

第二种方法是依据多维数组本质上是一个复杂元素的一维数组而确定的，如下
```c
int tow_dim[3][5] = {
    {00, 01, 02, 03, 04}, 
    {10, 11, 12, 13, 14}, 
    {20, 21, 22, 23, 24}, 
}
```

two_dim本质上是个包含三个复杂元素的数组，所以最外层需要三个初始值，而对于这里的初始值内部，又是一个包含五个整型元素的数组，所以外层的每一个初始值本身又是一个五元素的一维数组的初始值列表。

那么究竟应该用哪种初始化的方法呢？第二种方法，原因一在于多用花括号有利于显式的表面数组初始化值的结构，增加易读性；原因二在于若是不完整的初始化，即只初始化多维数组中的零散的几个元素，此时使用方法一要列从0开始到最后一个需要初始化的元素，可能要列很长，但是使用方法二只需要有对应结构就可以了（好像也没有提供多大便捷，只能初始化每维的连续前几个）。

#### 指针数组

顾名思义，就是由指针组成的数组，其声明的语句如下
```c
int *p[10];
```

看懂声明的方法就是假设右边为表达式并对其求值，得到的结果的类型与左边相同，由于下标应用的优先级比解引用更高，所以p先进行下标操作，在进行解引用，由此推测出p是由**指向整型的指针组成的数组**，并且已经分配好了内存大小。

要与之区分的是如下语句
```c
int (*p)[10];
```

该语句声明了一个**指向拥有十个整型的数组的指针**，通常作为一个二维数组`int matrix[3][10]`中`matrix[0]`的类型，通常在函数形参这么写。

上述两个式子有本质的不同，需要加以区分。

### 九、字符串、字符和字节

#### 不受限制的字符串函数

**复制字符串**

```c
char *strcpy(char *dst, const char *src);
```

- 此函数将src字符串覆盖复制到dst中
- 若dst和src内存位置重叠，则结果未定义
- src必须是个字符串，以NUL字符结尾，否则函数将不知道src何时结尾，最后以随机的大小长度复制到dst中
- dst的大小必须足够容纳src和NUL字符，否则仍然复制，但是会造成dst数组溢出
- 函数的返回值都是dst指针的副本

**连接字符串**

```c
char *strcat(char *dst, const char *src);
```

- str首先会找到dst的末位，并将src连接到dst的末位，连接形成新的字符串
- dst和src内存发生重叠，结果仍然未定义
- 必须保证dst字符数组的大小能够包含dst和src两个字符串

- 函数的返回值都是dst指针的副本

**字符串比较**

```c
int strcmp(const char *s1, const char *s2);
```

- 字符串是通过一个个比较相应字符，通过第一个出现不同的字符来判断大小，如果全部相同则两个字符串相同
- 若s1小于s2，则函数返回一个小于零的值，若s1大于s2，则函数返回一个大于零的值，相同则返回零
- 注意我没有说函数返回只能是-1、1和0，我说的是小于零、大于零和返回零，标准没有规定具体值
- 注意strcmp的返回值不应该当为布尔值，原因在于其有三个返回值，所以类似于`if (strcmp(a, b))`的写法是不好的，正确的写法应该是将函数的返回值与0作比较

#### 长度受限的字符串函数

```c
char *strncpy(char *dst, const char *src, size_t len);
char *strncat(char *dst, const char *src, size_t len);
char *strncmp(const char *s1, const char *s2, size_t len);
```

strncpy是将src的len个字符复制到src中，注意如果src的len个字符中**不包含NUL字符，则复制后也没有NUL字符**。若len长度大于src字符长度，则剩下的用NUL字符来填补。

strcat是将src的len个字符补到dst后面，若len比src长，则直接将src复制到dst结尾，不管len；若len比src短，则复制len个src的字符后自动补NUL字符。

strncmp比较前len个字符。

#### 字符串查找基础

**用int表示字符类型**
关于一些函数会使用int类型的形参来表示字符这件事，首先使用int类型表示char是可以的，因为int表示的范围要比char的范围要广泛，所以int可支持可能存在的字符集拓展，提高了移植性。
但是值得注意的是，单单只是用int用来表示char是没有问题的，但是若将int的指针用来表示char是万万不可的。
比如`char *strchr(const char *str, int ch);`用int来表示字符ch，但是一旦涉及到了指针的概念，就使用char，比如返回的指向char的指针和传入的字符数组。

**查找字符**

```c
char *strchr(const char *str, int ch);
char *strrchr(const char *str, int ch);
```

这两个函数是用与**查找一个字符**的函数，第一个函数返回ch第一次出现在str的位置所代表的指针，第二个函数则返回ch最后一个在str中出现的位置的指针。

```c
char *strpbrk(const char *str, const char *group);
```

这个函数用于在str中查找第一次出现的某字符，这个某字符是group中的任意一个，如
```c
const char string[] = "Hello there, honey."
ans = strpbrk(string, "aeiou");
```

返回的是string + 1也就是第一个e的位置。

**查找子串**

```c
char *strstr(const char *s1, const char *s2);
```

就是字符串匹配，和之前写得kmp算法一样，没有匹配则返回NULL。

#### 高级字符串查找

**查找一个字符串的前缀**

```c
size_t strspn(const char *str, const char *group);
size_t strcspn(const char *str, const char *group);
```

对于`strspn`函数，提供给group一个字符或多个字符（以字符串的形式），然后函数会从起始位置开始匹配并跳过出现在group的字符，直到出现第一个不属于group的字符，返回出现不属于group字符之前属于group字符的统计数量。

而`strcspn`函数正好与`strspn`相反，它是跳过不存在于group的字符，直到第一个属于group的字符的统计。

例如
```c
int len1, len2;
char buffer[] = "25,142,330,Smith,J,239-4123";
len1 = strspn(buffer, "0123456789");
len2 = strspn(buffer, ",0123456789");
```

运行代码，最后得到的结果为len1为2，len2为11。对于len1，函数在匹配到`','`的时候结束，返回前面的字符数量为2；对于len2，函数匹配到`'S'`的时候结束，返回前面的字符数量。

之所以叫做查找一个字符串的前缀，就是在于你知道有了前缀的信息，就可以跳过前缀找到一个不属于前缀的字符串，如
```c
ptr = buffer + strspn(buffer, "\n\r\f\t\v");
```

**查找标记**

```c
char *strtok(char *str, const char *sep);
```

该函数先跳过分隔符，然后会寻找str中被sep包含的任一字符（分隔符集），将第一次找到该字符设置为NUL字符，并将此位置保存，返回这一段的开头，下次使用时应将str参数传入NULL，由此这个函数会提取上一次所获得的标志，开始，跳过分隔符，找到下一个分隔符，并返回跳过分隔符后的开头指针，直到没有分隔符则返回NULL，这也通常作为分隔完成的标识，如下为经典用法
```c
void print_tokens(char *line) {
    static char whitespace[] = " \t\f\r\v\n";
    char *token;
    
    for (token = strtok(line, whitespace); 
         token != NULL; 
         token = strtok(NULL, whitespace)) {
        // token就是被分隔的子串
        printf("Next token is %s", token);
    }
}
```

原函数中对于sep分隔符的保存是使用哈希表来实现的，并且使用位操作来减小内存的占用，具体代码如下
```c
unsigned char map[32];
/* Clear control map */
for (count = 0; count < 32; count++)
    map[count] = 0;

/* Set bits in delimiter table */
do {
	map[*ctrl >> 3] |= (1 << (*ctrl & 7));
} while (*ctrl++);	// 太妙了这个代码
```

其中ctrl是指向用于分隔的字符串sep的指针，分隔字符的类型是char，共有256个不同的字符，每一个unsigned char变量有8位，所以声明32个unsigned char的数组就共有256位，数组中的256个位分别对应着256个字符，所以是散列关系。

上述代码中`*ctr >> 3`相当于`*ctr / 8`、`*ctr & 7`相当于`*ctr % 8`，因为7的二进制是0111，而与的关系就是保存了小三位而其他位清0，所以是取余。

**strtok存储上次调用值函数编写指南**
类似于strtok的函数都有利用上次调用该函数时所存储的信息，这一操作依托于再代码块中的静态变量static关键字。

- 一些常规的变量声明，包括static的变量声明，其初始化的结果可以是0或NULL
- 一些无关静态变量的操作，比如strtok函数建立字符的散列表，或是参数不符合条件直接退出
- 对对静态变量赋值，比如string是NULL就采样上次保存的，否则采用传来的的string
- 其他的操作
- 若_token值需要更新，则紧接其后跟新

**位操作散列表编写指南**
*待学习补充*

#### 内存操作

```c
void *memcpy(void *dst, const void *src, size_t length);
void *memmove(void *dst, const void *src, size_t length);
void *memcmp(const void *a, const void *b, size_t length);
void *memset(void *a, int ch, size_t length);
```

第一个函数与strncpy类似，将src中的length个字符复制到dst中，并且其遇到NUL字符不会停止，若内存重叠，及如果同样未定义。

第二个函数再memcpy的基础上支持内存重叠，原因在于它是先将src中的length个字符复制到临时数组，再将临时数组复制到dst中，所以支持内存重叠的情况，对于数组元素的移动应该很方便。

第三个函数比较，没什么需要注意的地方。

最后一个函数是将从a开始的length个字符都设置为字符，应该适合用来初始化。

**注意：上述的类型是void类型，所以传入长度时需要按照字节的长度计算。不会用！不看了！**

### 十、结构和联合

#### 结构基础知识

如果你在你的程序中进行了两次的结构声明，即使这两次结构声明的列表成员完全相同，它们两个也会被编译器当作两种截然不同的类型，即指向某一种结构的指针不能由另外一种结构的地址来赋值，正确的做法就是利用结构声明的标签来表示这个结构变量。

结构标签需要和类型名分别开来，结构标签用来表示类型需要前面加上struct关键字，而类型名直接可以用于声明变量，两者可以用typedef关键字来联系。

结构的子引用，在结构的内部在使用自己是违法的，但是在内部使用指向自己的指针是正确的用法，并且还很常用，原因在于指向结构的指针由于仅用于存储地址，所以所占用的内存大小是早已确定的，故可以顺利的在结构中声明指向自己的指针，但是使用声明的指针一定是要已经定义过的。

**不完整的声明**
有时会存在两个结构相互包含的关系，即一个结构中包含另一个结构的指针，另一个结构包含这个结构的指针，那么此时需要先声明哪一个结构呢？这个问题可以通过使用不完整声明（incomplete declaration），其方式就是先声明结构的标识符，然后就可以利用在不需要结构长度信息的语句上，如声明指向该结构的指针，再后面实际定义了这个结构之后，就会自动将不完整的声明和完整声明链接在一起，由此可以解决结构之间相互包含的声明问题。
如果不完整的声明不通过指针来使用，编译器会报错*'xx ' has incomplete type.*

**结构的初始化**
和一维数组的初始化类似，花括号用于包括用逗号分隔的按照顺序的初始值，在内部仍可用花括号来作为初始化结构内部的聚合数据类型（数组和结构），如

```c
struct INIT_EX {
    int a;
    short b[10];
    Simple c;
} x = {
    10,
    {1, 2, 3, 4, 5}, 
    {25, 'x', 1.9}
};
```

#### 结构的存储分配

p205页，我没有搞很懂

#### 作为函数参数的结构

将结构直接按值传参的方式是不合时宜的，因为当结构较大时额外的拷贝开销就较大；而使用指针就要方便得多，然而对指针的间接访问仍然会造成一定开销，当需要间接访问超过两三次，就可向形参声明添加关键字register；若你要改变传入的参数，使用指针是几乎最好的解决方案。

#### 位段

位段（bit field），可以间接的实现查询某变量中不同的位，他作为一个结构，里面的成员都对应不同数量的位，并且位段成员必须声明为signed int和unsigned int类型，如
```c
struct CHAR {
    unsigned ch : 7;
    unsigned font : 6;
    unsigned size : 19;
}
```

使用上述的位段，可以将ch存储7位数量的字符，font存储6位数量的字体，19位数量的size大小。

使用位段可以方便的访问寄存器的内容，如
```c
struct DISK_REGISTER_FORMAT {
    unsigned command 		 : 5;
    unsigned sector 		 : 5;
    unsigned track 			 : 5;
    unsigned erroe_code 	 : 5;
    unsigned head_loaded 	 : 1;
    unsigned write_protext 	 : 1;
    unsigned disk_spinning 	 : 1;
    unsigned error_occurred  : 1;
    unsigned ready 			 : 1;
}
#define DISK_REGISTER ((struct DISK_REGISTER_FORMAT *)0xc0200142)	// 寄存器地址
```

由此便可通过位段来访问和操作寄存器的位
```c
DISK_REGISTER->sector = new_sector;
...
```

**移植性的问题**
可移植性程序要避免使用位段，原因如下

- int不知道被当作有符号数还是无符号数，不过这点可以同一改为无符号数来声明
- int是16位还是32位
- 内存是由左到右分配还是由右到左分配

位段内容还需加强。

#### 联合

联合可以实现多种类型存于同一地址，同一长度的内存中，并且你可以指定存储时数据的类型和使用时数据的类型，如
```c
union {
    float f;
    int i;
} fi;
fi.f = 3.1415;
printf("%d", fi.i);
```

上例实现了对于某一个联合变量，使用浮点类型存储，用整型输出。

联合的内存长度就是它最长成员的长度。

联合类型在初始化的时候默认是以第一个元素的类型来初始化的。

### 十一、动态内存分配

数组的分配需要在编译的时候知道准确的大小，所以只能用常量来声明，静态数组在编译的时候就分配好内存，自动变量在编译的时候只需要直到其大小信息。

```c
void *malloc(size_t size);
void free(void *pointer);
```

对于malloc函数来说，需要注意的是一定要在使用后判别返回的指针是否是NULL指针，还有就是返回的类型是void *类型，标准说void *类型可以转换成其他任何类型，在一些编译器上要强制转换。由于指针都是要实现声明好类型的，所以在使用malloc函数的时候就已经默认转换成了相应类型了，可以不用添加前面的(int *)来类型转换，malloc函数分配的内存没有初始化。

free函数就是用于释放动态分配的内存，如果传入的指针是NULL，那不会发生任何事情。

```c
void *calloc(size_t num_elements, size_t element_size);
void *realloc(void *ptr, size_t new_size);
```

calloc函数同样用于分配内存，只不过其顺带给分配的内存初始化为0，并且其传入的参数也和malloc不同，其需要的先是数量后是类型的大小。

realloc函数用于修改一个已经分配内存块的大小，可扩充可缩小，若扩充，则会在已经分配的内存的后面分配，如果后面不够，就会整体重新安排另外一个连续的位置，并把前面已经分配的数据复制到新分配的内存区域；若缩小，则直接减小后面相应大小的内存，保留前面的数据。注意因为扩充是要重新找一个内存，所以指针会改变，所以无比要使用新的指针值。如果第一个参数为NULL，则与malloc函数一模一样，注意realloc没有返回值。

三个函数分配的内存都存于静态内存中，所以当调用函数中请求分配，函数调用结束后不会释放分配的内存，而会一直存在，知道free是释放。

注意三个函数返回的都是指针，而这些指针都是要使用的。下面为使用实例：

```c
int *pint1 = NULL;
int *pint2 = NULL;
int *pint3 = NULL;
pint1 = malloc(sizeof(int) * 10);	// 分配十个位置的数组
pint2 = calloc(10, sizeof(int)); 	// 分配十个位置的数组并且初始化为0
pint3 = realloc(NULL, sizeof(int) * 10);	// 和pint1的效果完全一致
pint2 = realloc(pint2, sizeof(int) * 20);	//	在pint2初始化为0的大小为十的数组中扩充至大小20，但新扩充的没有初始化。
```

 #### 内存泄漏

分配动态内存后，使用完毕不释放将会引起内存泄漏。当程序不断的运行，就会不断的像内存池新申请内存，但是使用完毕后没有释放，内存池就被不但的榨干，从而导致程序崩溃，这就是内存泄漏，内存随着程序错误的运行慢慢的被填满，最终崩溃。

### 十二、使用结构指针

*这章主要讲链表数据结构，已经在《数据结构和算法分析》这本书中初略了解，故跳过。*

### 十三、高级指针话题

#### 高级声明

如何推断出一个复杂的声明？可以使用“推论声明”，也就是认为声明变量的表达式和普通的表达式在求值时所使用的规则相同，所以在推测复杂的声明表达式时，只需要将变量名当作一个变量，并根据操作符的优先级和结合律对其求值，所得为最右边的类型，由此即可推得声明。如
```c
int *f();
```

找到变量名`f`，并将其视为一个变量，由于`()`操作符比`*`操作符优先级高，所以率先进行调用操作符操作，由此`f`便是函数，将函数的返回值进行`*`解引用操作而得到`int`类型变量，所以f函数的返回值为整型。

程序中的每个函数都位于内存中的某个位置，故存在**函数指针**。

函数的返回值只能返回标量，不能返回数组。

对于`int f[]()`来说，f调用后是函数，所以`f`是一个由返回整型的函数组成的数组，但是声明是非法的，因为不存在函数组成的数组，因为函数的大小很可能不同，数组的元素大小必须相同。

对于`int (*f[])()`来说，`f`下标引用后在解引用后为返回整型的函数，所以`f`是由函数指针形成的数组。

实际运用中还是先右再左的顺序更好做。

#### 函数指针

函数指针和一般的指针相同，单独的初始化并不意味着其能够使用，使用之前还需先初始化为某个函数的地址，如

```c
int f(int);
int (*pf)(int) = &f;
```

上述` &`也可省去，因为函数名被单独使用时，编译器往往将其隐式转换为函数指针，而`&`只是显式说明了这一操作。

程序调用函数的流程：编译器在遇到函数名是，会将其转换成函数指针，从而跳转到函数指针指向的位置从而调用函数。举个例子，如果有下列的语句
```c
ans = f(25);
ans = (*pf)(25);
ans = pf(25);
```

第一句的操作正如刚才述说的，将函数名`f`隐式转化为函数指针，从而跳转到函数对应的地址从而调用；第二句中，`pf`解引用后为函数名，但实际上函数名还是会被转换回来为函数指针，所以效果同样是调用函数；第三局则直接得多，`pf`由于直接代表函数指针，所以编译器不再需要转换，从而直接跳转到对应的位置来调用函数。

**回调函数**
使用回调技巧的函数称为回调函数（callback function），用户会将一个函数指针作为参数传给这个函数，而这个函数会“回调”用户所传入的函数，所以称为回调函数。

对于查找程序，传入的函数为`compare`，需要注意的是，compare的形参和回调函数的形参都必须是`void *`类型，由此才可以支持不同类型来使用函数，但是具体到传入的`compare`函数，也需要不同的类型来特化，比如成为`compare_int`，并且使用是传入的`void *`类型都需要强制转化为`int *`类型。
```c
int compare(void *lhs, void *rhs);	// 返回值是int，因为比较大小只有大于0、小于0和等于0
```



标准库中比较函数的规范一般是，相等返回零，不相等返回非零，其中第一个参数大返回正值，第二个参数大返回负值。

**转移表**
转换表的操作适合用于替代switch语句，如果switch的操作表对应从零开始，并且每一种可能，对应一个函数操作，便可使用转换表。转换表的实质就是由不同的函数指针组成的数组，这些函数指针拥有类似的操作，相同的形参和相同类型的返回值，将其包装成一个数组，便可通过调用数组来调用函数，而调用数组的下标便对应每种可能性的下标，如下例子

```c
double (*oper_func[])(double, double) = {
    add, sub, mul, div, ...
}
```

其中add、sub等对应一个函数，在上述函数指针数组的声明之后，便可使用如下的方式来调用以实现转换表的功能
```c
result = oper_func[oper](op1, op2);
```

可用上述的技巧来替代switch那繁琐的语句
```c
switch (oper) {
    case ADD:
        result = add(op1, op2);
        break;
    case SUB:
        result = sub(op1, op2);
        break;
    ...
}
```

在使用转换表时，需要注意的是函数指针组成的数组，此时的越界将造成更大的危害，以及难以检出。

- 若下标值远远超出了边界，达到了分配给该程序之外的内存，则该错误有时会被系统找到并终止，错误提示在数组引用附近，易找出。
- 但如果未被系统找出，即程序当作有效值跳转到了另外的地方，此时常常会由于操作符等的关系而报错，但是此时函数已经跳转到了其他地方，所以更难被定位错误，此时就需要堆栈中返回的地址。
- 更糟的是，如果前面都没出问题，那么错误的程序将会运行得更远，更难将问题定位，通过在查找表前后打印信息可以定位错误，但是又怎么想的到某个错误会与远在天边的转换表有关联呢？
- 所以一开始使用转换表的时候就要保证下标的使用位于合法的范围内。

数组操作一定要时刻注意超出边界的问题。

#### 命令行参数

C程序的命令行参数就是main函数的两个参数，其函数原型`int main(int argv, char **argv)`。先说第二个参数，argv是一个指向字符指针的指针，而一个字符指针可用来表示一个字符串（字符数组），所以argv也可看出指向字符串的指针，故用argv来表示一个由字符串组成的数组。这个数组的第一个参数是程序名，注意第二个参数的字符串数组是以NULL结尾的，使用下列代码可以将该字符串打印（更详细的图例可以参考中文版本的P265图13.1）
```c
/* command_line.c */
#include <stdio.h>
#include <stdlib.h>
	
int main(int argc, char **argv) {	// char **argv == char *argv[]
    while (*argv != NULL) {
        printf("%s\n", *argv++);
    }
    return EXIT_SUCCESS;
}
```

其最终得到的输出`E:\Code\C_2022\pointers_on_c\Chapter13\bin\command_line.exe`，也就是程序名。

现在说回第一个参数argc，他用来表示第二个字符串数组的大小，用argc和NULL结尾都可以用来标记这个数组的大小，argc是不包括NULL的。

*处理命令行参数没咋看懂，等要用到的时候在说，这里插个眼*

**编程小技巧**

```c
while (*string++ != '\0') {
    ++lengtn;
}
```

主要的技巧在判断语句，该函数会一次遍历string数组，直到不符合条件则会终止循环，需要注意的是，该语句在进行最后一次判断的时候仍然是有递增的，所以跳出循环时string的值是指向跳出循环的下一个指针，与下面的循环有些许不同。
```c
while (*string != '\0') {
    ++string;
    ++length;
}
```

还有一种循环语句
```c
while (*++argv != NULL) {
    ...
}
```

该语句终止循环时不会指向下一个元素，但是他会跳过第一个元素。

#### 字符串常量

当字符串常量出现于表达式中，它的值就是一个指针常量，其指向字符，用来代表这个字符串常量，编译器会把你所指定的字符串常量的副本存储与内存中的某个位置，所以对其进行一些属于指针的操作也是可以的，只要你不改变内容，因为这是未定义行为。

你可以通过一个表达式来控制字符串的数量`"********** + 10 - n"`；
也可以简洁的使用字符串的散列表`"0123456789ABCDEF"[VALUE % 16]`，来打印16位进制数。

使用这种技巧时，请写上注释，不加注释别人看不懂，加了注释别人会比传统代码更容易看懂，因为更短。

### 十四、预处理器

#### #define

#define可以用于多行

```c
#define DUBUR_PRINT printf("File %s line %d: " \
                        "x = %d, y = %d, z = %d\n", \
                        __FILE__, __LINE__, \
                        x, y, z)
```

利用反斜杠可以将很长的一行分成几行，反斜杠`\`要是再空格符有意义的地方（如字符串内）分隔，空格不会清除，但是其在不同部分的连接处等这些空格无用的地方（字符串外），如同C语言其他地方省略空格一样，会省去define中多余的空格，所以后面的部分只要不涉及字符串就可以尽情的空格。

两个相邻的字面量字符串会被自动连接成一个字符串，并且这个自动连接的优先级很高，比如`"abcdef" "ghijk"[8]`最后输出为`'i'`，下标优先级要小于相邻字面量连接的优先级，等效为`"abcdefghijk"[8]`。

**宏**
`#define`允许将参数替换到文本中，这种实现通常称为宏。

```c
#define name(parameter-list) stuff
```

括号紧邻name用来表示所属关系，否则会将括号视为stuff的一部分。stuff中包含括号内的参数，预处理时，将括号内的参数对应文本替换到stuff中，在调用中，括号内的参数是完美无瑕的复制到文本中。

**注意，使用时需要在每个变量和总的表达式中扩上括号**。

不要尝试用#define宏来模仿其它语言的规则，并不是所有人都理解你新建的规则，这样会使代码难以理解。

不要在使用宏的时候使用带副作用的参数，因为在实际的宏定义中，参数不知使用一次，而宏仅仅只将宏参数拷贝到对应位置，所以会连带将副作用也执行多次，从而出现出乎意料的情况。

可以使用`#undef`来移除一个宏定义。

预处理器的处理流程是查找当前源文件需要替换的字符，然后重复上一步骤直到文件中不再需要预处理操作，基于这一原理，预处理的操作是**可以嵌套**的。

### 条件编译

条件编译（conditional compilation）的基本语法如下
```c
#if constant-expression
		statements
#elif constant-expresion
    	other statements
#else
		other statements
#endif
```

其中constant-expression必须是已经知道的常量表达式，即包括字面量或由define定义的字符，不能是变量即使是const

实际上可以把所有的#include换成双引号，因为此时编译器会先查找当前文件夹，实在找不到才到库函数中查找头文件，但是尖括号和双引号的区分使用可以清楚的告诉读者哪一个是标准库函数头文件，哪一个是自定义的头文件。

### 十五、输入/输出函数

ANSI C的规范里包含了函数库，每种编译器都需要支持一组指定的函数，包括接口和功能，你依旧可以使用拓展的普通函数库，你也可以使用标准所规定的标准库函数来满足移植性的要求。

#### 错误报告

标准库函数定义了一个整型外部变量`errno`（`errno.h`中定义），每当使用某个函数的某个操作时发生了错误，或许程序没有马上终止（比如使用`fopen`函数打开读取了一个不存在的文件），此时就会更新`errno`这个变量的内容，并使用`perror`函数来打印错误的信息。
```c
void perror(const char *message)
```

例如使用
```c
FILE *input;
input = fopen("data3", "r");	// data3这个文件不存在
if (input == NULL) {
    perror("data3");
    exit(EXIT_FAILURE);
}
```

就会最终输出`data3: No such file or directory`。

#### 终止执行

使用定义在``stdlib.h``中的`exit`函数
```c
void exit(int status);
```

参数status返回给系统，和main中返回的0一样，用于提示该程序是否正常完成，可以配合使用预定义的符号`EXIT_SUCCESS`和`EXIT_FAILURE`来标志程序终止是因为成功还是失败。

#### 标准I/O函数库

最早的K&R C提供的I/O函数很少，故有了标准I/O函数库，拓展了很多的额外功能，但是其以来特定类型的机器，一台==不同机子运行情况不一样，如果将其修改又会造成移植性的降低，简而言之就是移植性差，最后出现了ANSI I/O函数。

#### ANSI I/O概念

**流**

- 计算机有很多的与I/O有关的设备，操作系统为程序员提供一个更为简单和统一的I/O接口，C再将其进一步抽象为流，也就是说，每种设备的I/O接口对应一个流，标准输入和标准输出就是默认的流，通常为键盘和显示器终端。
- 对于C程序而言，I/O操作就是简单的从程序已进字节或移出字节，这种字节流称为流（stream）。
- 完全缓冲（fully buffered），程序只在缓冲区来回重复的复制数据，缓存区满时和缓存区空时刷新。
- 流分为文本流和二进制流。

**文件**
FILE结构是一个数据结构，用于访问流，通常用指向FILE的指针来关联流。

#### 打开流

```c
FILE *fopen(const char *name, const char *mode);
```

name就是打开的文件名字符串，可以是相对路径或绝对路径。字符串mode就是打开的模式，如下

|        | 读取 | 写入 | 添加 |
| ------ | ---- | ---- | ---- |
| 文本   | "r"  | "w"  | "a"  |
| 二进制 | "rb" | "wb" | "ab" |

#### 关闭流

```c
int fclose(FILE *f);
```

先刷新缓存区，然后关闭文件，成功返回0，失败返回EOF。

```c
if (fclose(input) != 0) {
    perror("fclose");
    exit(EXIT_FAILURE);
}
```

#### 字符I/O

流被打开之后，可以对其进行输入和输出操作，若为字符输入，则将由以下函数从流中读取字符
```c
/* 输入字符相关 */
int fget(FILE *stream);
int getc(FILE *stream);
int getchar(void);
```

getchar直接从标准输入读取。

getc和fgetc以流作为参数，读取一个字符作为返回值返回，下次执行时读取下一个字符，以此递推，直到没有字符或碰到EOF时返回EOF，读取结束，这两个函数使用起来没什么区别。

可以使用以下的函数用来将字符写入流中
```c
/* 输出字符相关 */
int fputc(int character, FILE *stream);
int putc(int character, FILE *stream);
int putchar(int character);
```

同样`putchar`是将character输入到标准输出中。

putc和fputc是将character输出到stream流中。

**字符宏**
书上说，只有fgetc和fputc是真正的函数，而getc、putc、getchar和putchar等都是宏。

**撤销字符I/O**
可以使用ungetc这个函数来前一个读取的字符返回流中，目前只知道他能退一个字符，其他具体的细节等用到时再查。

#### 未格式化的行I/O

```c
/* 得到一行字符串 */
char *fgets(char *buffer, int buffer_size, FILE *stream);
char *gets(char *buffer);
```

fgets函数用于从stream中读取一行字符串（最后以换行符结尾），复制到buffer数组中，若读取了buffer_size-1个字符了都还没遇见换行符，则自动结束，将字符串的最后一个元素以`'\0'`结尾，剩下的字符仍然存在流中。

gets函数的用法可以理解为没有buffer_size限制的，默认为标准输入流的fgets。

不想写了，这些函数不懂了再来具体查吧。P308

...

**关于scanf为什么用指针这件事**
scanf本质上是一个函数，其函数的原型为`int scanf(FILE *stream, const char *foemat, ...);`其中省略号是可变数量的函数形参，由于C语言函数按值传递的机制，所以要想为某个不属于该函数的变量赋值，必须要知道该变量的地址，所以要传地，使用指针。
